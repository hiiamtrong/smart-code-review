#!/usr/bin/env bash
set -e

# AI Review CLI Tool
VERSION="1.0.7"

# Colors for output
RED=$'\033[0;31m'
GREEN=$'\033[0;32m'
YELLOW=$'\033[1;33m'
BLUE=$'\033[0;34m'
CYAN=$'\033[0;36m'
BOLD=$'\033[1m'
NC=$'\033[0m' # No Color

# Paths
CONFIG_DIR="$HOME/.config/ai-review"
CONFIG_FILE="$CONFIG_DIR/config"
HOOKS_DIR="$CONFIG_DIR/hooks"
HOOK_SCRIPT="$HOOKS_DIR/pre-commit.sh"

# Hook marker to identify our hook
HOOK_MARKER="# AI-REVIEW-HOOK"

# ============================================
# Helper Functions
# ============================================

log_error() {
  echo -e "${RED}[ERROR]${NC} $1" >&2
}

log_success() {
  echo -e "${GREEN}[OK]${NC} $1"
}

log_warn() {
  echo -e "${YELLOW}[WARN]${NC} $1"
}

log_info() {
  echo -e "${BLUE}[INFO]${NC} $1"
}

check_git_repo() {
  if ! git rev-parse --is-inside-work-tree &> /dev/null; then
    log_error "Not a git repository"
    exit 1
  fi
}

check_config_exists() {
  if [[ ! -f "$CONFIG_FILE" ]]; then
    log_error "Configuration not found"
    echo "Run 'ai-review setup' to configure credentials"
    exit 1
  fi
}

get_git_hooks_dir() {
  local repo_root=$(git rev-parse --show-toplevel 2>/dev/null)

  # Check for husky (v5+)
  if [[ -d "$repo_root/.husky" ]]; then
    echo "$repo_root/.husky"
    return
  fi

  # Check for custom hooksPath
  local custom_path=$(git config core.hooksPath 2>/dev/null)
  if [[ -n "$custom_path" ]]; then
    # Resolve relative path
    if [[ "$custom_path" != /* ]]; then
      custom_path="$repo_root/$custom_path"
    fi
    echo "$custom_path"
    return
  fi

  # Default: .git/hooks
  git rev-parse --git-dir 2>/dev/null | xargs -I {} echo "{}/hooks"
}

get_hook_type() {
  local hooks_dir="$1"
  if [[ "$hooks_dir" == *".husky"* ]]; then
    echo "husky"
  else
    echo "git"
  fi
}

# ============================================
# Commands
# ============================================

cmd_setup() {
  echo -e "${BOLD}AI Review Setup${NC}"
  echo ""

  # Create config directory if needed
  mkdir -p "$CONFIG_DIR"

  # Load existing values if config exists
  local OLD_URL="" OLD_KEY="" OLD_MODEL="" OLD_PROVIDER=""
  local OLD_ENABLE_SONAR="" OLD_SONAR_URL="" OLD_SONAR_TOKEN="" OLD_SONAR_HOTSPOTS=""
  if [[ -f "$CONFIG_FILE" ]]; then
    source "$CONFIG_FILE" 2>/dev/null || true
    OLD_URL="$AI_GATEWAY_URL"
    OLD_KEY="$AI_GATEWAY_API_KEY"
    OLD_MODEL="$AI_MODEL"
    OLD_PROVIDER="$AI_PROVIDER"
    OLD_ENABLE_SONAR="$ENABLE_SONARQUBE_LOCAL"
    OLD_SONAR_URL="$SONAR_HOST_URL"
    OLD_SONAR_TOKEN="$SONAR_TOKEN"
    OLD_SONAR_HOTSPOTS="$SONAR_BLOCK_ON_HOTSPOTS"

    log_warn "Configuration already exists"
    read -p "Do you want to overwrite it? [y/N]: " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
      echo "Setup cancelled"
      exit 0
    fi
    echo ""
    log_info "Press Enter to keep existing value"
  fi

  # --- AI Gateway ---
  echo -e "${BOLD}AI Gateway Configuration:${NC}"
  echo ""

  # AI Gateway URL
  if [[ -n "$OLD_URL" ]]; then
    read -p "  AI Gateway URL [$OLD_URL]: " AI_GATEWAY_URL
    AI_GATEWAY_URL="${AI_GATEWAY_URL:-$OLD_URL}"
  else
    read -p "  AI Gateway URL: " AI_GATEWAY_URL
    while [[ -z "$AI_GATEWAY_URL" ]]; do
      log_error "URL is required"
      read -p "  AI Gateway URL: " AI_GATEWAY_URL
    done
  fi

  # AI Gateway API Key
  if [[ -n "$OLD_KEY" ]]; then
    local masked_key="${OLD_KEY:0:4}****${OLD_KEY: -4}"
    read -sp "  AI Gateway API Key [$masked_key]: " AI_GATEWAY_API_KEY
    echo ""
    AI_GATEWAY_API_KEY="${AI_GATEWAY_API_KEY:-$OLD_KEY}"
  else
    read -sp "  AI Gateway API Key: " AI_GATEWAY_API_KEY
    echo ""
    while [[ -z "$AI_GATEWAY_API_KEY" ]]; do
      log_error "API Key is required"
      read -sp "  AI Gateway API Key: " AI_GATEWAY_API_KEY
      echo ""
    done
  fi

  # AI Model (optional)
  local default_model="${OLD_MODEL:-gemini-2.0-flash}"
  read -p "  AI Model [$default_model]: " AI_MODEL
  AI_MODEL="${AI_MODEL:-$default_model}"

  # AI Provider (optional)
  local default_provider="${OLD_PROVIDER:-google}"
  read -p "  AI Provider [$default_provider]: " AI_PROVIDER
  AI_PROVIDER="${AI_PROVIDER:-$default_provider}"

  # --- SonarQube ---
  echo ""
  echo -e "${BOLD}SonarQube Configuration:${NC}"
  echo ""

  local default_enable="${OLD_ENABLE_SONAR:-false}"
  if [[ "$default_enable" == "true" ]]; then
    read -p "  Enable SonarQube for local commits? [Y/n]: " enable_sonar
    enable_sonar="${enable_sonar:-y}"
  else
    read -p "  Enable SonarQube for local commits? [y/N]: " enable_sonar
    enable_sonar="${enable_sonar:-n}"
  fi

  if [[ "$enable_sonar" == "y" || "$enable_sonar" == "Y" ]]; then
    ENABLE_SONARQUBE_LOCAL="true"

    # SonarQube Host URL
    local default_sonar_url="${OLD_SONAR_URL:-https://sonarqube.sotatek.works}"
    read -p "  SonarQube Host URL [$default_sonar_url]: " SONAR_HOST_URL
    SONAR_HOST_URL="${SONAR_HOST_URL:-$default_sonar_url}"

    # SonarQube Token
    if [[ -n "$OLD_SONAR_TOKEN" ]]; then
      local masked_token="${OLD_SONAR_TOKEN:0:4}****${OLD_SONAR_TOKEN: -4}"
      read -sp "  SonarQube Token [$masked_token]: " SONAR_TOKEN
      echo ""
      SONAR_TOKEN="${SONAR_TOKEN:-$OLD_SONAR_TOKEN}"
    else
      read -sp "  SonarQube Token: " SONAR_TOKEN
      echo ""
      while [[ -z "$SONAR_TOKEN" ]]; do
        log_error "Token is required when SonarQube is enabled"
        read -sp "  SonarQube Token: " SONAR_TOKEN
        echo ""
      done
    fi

    # Block on hotspots
    local default_hotspots="${OLD_SONAR_HOTSPOTS:-true}"
    if [[ "$default_hotspots" == "true" ]]; then
      read -p "  Block commits on Security Hotspots? [Y/n]: " block_hotspots
      block_hotspots="${block_hotspots:-y}"
    else
      read -p "  Block commits on Security Hotspots? [y/N]: " block_hotspots
      block_hotspots="${block_hotspots:-n}"
    fi
    if [[ "$block_hotspots" == "y" || "$block_hotspots" == "Y" ]]; then
      SONAR_BLOCK_ON_HOTSPOTS="true"
    else
      SONAR_BLOCK_ON_HOTSPOTS="false"
    fi
  else
    ENABLE_SONARQUBE_LOCAL="false"
  fi

  # Save config
  cat > "$CONFIG_FILE" << EOF
# AI Review Configuration
# Generated by ai-review setup on $(date)

AI_GATEWAY_URL="$AI_GATEWAY_URL"
AI_GATEWAY_API_KEY="$AI_GATEWAY_API_KEY"
AI_MODEL="$AI_MODEL"
AI_PROVIDER="$AI_PROVIDER"
ENABLE_SONARQUBE_LOCAL="$ENABLE_SONARQUBE_LOCAL"
EOF

  if [[ "$ENABLE_SONARQUBE_LOCAL" == "true" ]]; then
    cat >> "$CONFIG_FILE" << EOF
SONAR_HOST_URL="$SONAR_HOST_URL"
SONAR_TOKEN="$SONAR_TOKEN"
SONAR_BLOCK_ON_HOTSPOTS="$SONAR_BLOCK_ON_HOTSPOTS"
EOF
  fi

  chmod 600 "$CONFIG_FILE"

  echo ""
  log_success "Configuration saved to $CONFIG_FILE"
  echo ""
  echo "Next steps:"
  echo "  1. Navigate to a git repository"
  echo "  2. Run: ai-review install"
}

# Create .sonarignore template in project root
create_sonarignore_template() {
  local repo_root=$(git rev-parse --show-toplevel)
  local sonarignore_file="$repo_root/.sonarignore"
  
  # Skip if .sonarignore already exists
  if [[ -f "$sonarignore_file" ]]; then
    log_info ".sonarignore already exists, skipping"
    return 0
  fi
  
  log_info "Creating .sonarignore template..."
  
  cat > "$sonarignore_file" << 'EOF'
# SonarQube Exclusions
# Exclude files/directories from SonarQube analysis
# Syntax: Similar to .gitignore (one pattern per line)

# IDE & Editor directories
.idea/
.vscode/
.cursor/
.vs/
.fleet/
*.swp
*.swo
*~
.DS_Store

# Build outputs
dist/
build/
target/
out/

# Dependencies
node_modules/
vendor/
.venv/
venv/

# Test files (customize as needed)
*.test.js
*.spec.ts
__tests__/

# Static assets (images, fonts, etc.)
public/assets/
static/images/
*.svg
*.png
*.jpg
*.jpeg
*.gif
*.woff
*.woff2
*.ttf

# Generated/minified files
*.min.js
*.min.css
*.bundle.js
*.generated.js
*-generated.ts

# Configuration
*.config.js

# Documentation
docs/
*.md

# Add your project-specific exclusions below:
# example-dir/
# legacy-code/

EOF

  log_success "Created .sonarignore template"
  echo "   Customize it to fit your project needs"
  echo "   Location: $sonarignore_file"
}

# Configure project-specific SonarQube settings
configure_project_sonarqube() {
  # Load global config to check if SonarQube is enabled
  if [[ ! -f "$CONFIG_FILE" ]]; then
    return 0
  fi
  
  source "$CONFIG_FILE"
  
  # Check if SonarQube is enabled locally
  if [[ "${ENABLE_SONARQUBE_LOCAL}" != "true" ]]; then
    return 0
  fi
  
  echo ""
  log_info "SonarQube is enabled - Project configuration needed"
  echo ""
  
  # Check if project key already exists in git config
  local existing_key=$(git config --local aireview.sonarProjectKey 2>/dev/null)
  
  if [[ -n "$existing_key" ]]; then
    echo "Current SonarQube Project Key: $existing_key"
    read -p "Keep this project key? [Y/n]: " keep_key
    if [[ "$keep_key" != "n" && "$keep_key" != "N" ]]; then
      return 0
    fi
  fi
  
  # Prompt for project key
  local repo_root=$(git rev-parse --show-toplevel)
  local default_key=$(basename "$repo_root" | sed 's/[^a-zA-Z0-9_-]/_/g')
  echo "Each project needs its own SonarQube Project Key"
  echo "This key identifies your project in SonarQube"
  echo ""
  read -p "Enter SonarQube Project Key [$default_key]: " project_key
  project_key="${project_key:-$default_key}"
  
  # Prompt for base branch
  echo ""
  echo "Which branch should SonarQube compare against?"
  echo "This is used to detect changed files for differential analysis"
  echo ""
  
  # Auto-detect default branch
  local default_branch=""
  if git rev-parse --verify main >/dev/null 2>&1; then
    default_branch="main"
  elif git rev-parse --verify master >/dev/null 2>&1; then
    default_branch="master"
  elif git rev-parse --verify develop >/dev/null 2>&1; then
    default_branch="develop"
  fi
  
  if [[ -n "$default_branch" ]]; then
    read -p "Enter base branch name [$default_branch]: " base_branch
    base_branch="${base_branch:-$default_branch}"
  else
    read -p "Enter base branch name [main]: " base_branch
    base_branch="${base_branch:-main}"
  fi
  
  # Save to git config (stored in .git/config, not committed)
  git config --local aireview.sonarProjectKey "$project_key"
  git config --local aireview.baseBranch "$base_branch"
  
  log_success "Project configuration saved to git config"
  echo "   Project Key: $project_key"
  echo "   Base Branch: $base_branch"
  echo "   Stored in: .git/config (not committed)"
}

cmd_install() {
  check_git_repo
  check_config_exists

  local hooks_dir=$(get_git_hooks_dir)
  local target_hook="$hooks_dir/pre-commit"
  local hook_type=$(get_hook_type "$hooks_dir")
  local original_hook="$hooks_dir/pre-commit.original"

  log_info "Installing AI Review hook..."
  log_info "Detected hook type: $hook_type"

  # Create hooks directory if needed
  mkdir -p "$hooks_dir"

  # Handle based on hook type
  if [[ "$hook_type" == "husky" ]]; then
    install_husky_hook "$target_hook"
  else
    install_git_hook "$target_hook" "$original_hook"
  fi

  chmod +x "$target_hook"

  # Create .sonarignore if it doesn't exist
  create_sonarignore_template
  
  # Configure project-specific SonarQube settings if enabled
  configure_project_sonarqube

  log_success "AI Review hook installed"
  echo ""
  echo "The hook will now run on every commit."
  echo "To bypass: git commit --no-verify"
}

# Install hook for husky-based projects
install_husky_hook() {
  local target_hook="$1"

  # Check if already installed
  if [[ -f "$target_hook" ]] && grep -q "$HOOK_MARKER" "$target_hook" 2>/dev/null; then
    log_warn "AI Review hook is already installed"
    read -p "Do you want to reinstall? [y/N]: " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
      echo "Aborted"
      exit 0
    fi
    # Remove our marker and AI review line, keep the rest
    local temp_file=$(mktemp)
    grep -v "$HOOK_MARKER" "$target_hook" | grep -v "$HOOK_SCRIPT" > "$temp_file"
    mv "$temp_file" "$target_hook"
  fi

  # For husky, append our call to existing hook
  if [[ -f "$target_hook" ]]; then
    # Read existing content
    local existing_content=$(cat "$target_hook")

    # Backup existing hook
    cp "$target_hook" "$target_hook.backup"
    log_info "Backed up existing hook"

    # Append AI review to existing hook
    cat > "$target_hook" << EOF
$existing_content

$HOOK_MARKER
# AI Review - run after other hooks
"$HOOK_SCRIPT" "\$@"
EOF
    log_info "Added AI Review to existing husky hook"
  else
    # No existing hook - create new one
    cat > "$target_hook" << EOF
$HOOK_MARKER
# AI Review pre-commit hook
"$HOOK_SCRIPT" "\$@"
EOF
  fi
}

# Install hook for standard git hooks
install_git_hook() {
  local target_hook="$1"
  local original_hook="$2"

  # Check if hook already exists
  if [[ -f "$target_hook" ]]; then
    if grep -q "$HOOK_MARKER" "$target_hook" 2>/dev/null; then
      log_warn "AI Review hook is already installed"
      read -p "Do you want to reinstall? [y/N]: " confirm
      if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo "Aborted"
        exit 0
      fi
      # Keep original hook if it exists
    else
      # Existing hook is not ours - save it to chain
      log_warn "A pre-commit hook already exists"
      echo "Current hook: $target_hook"
      echo ""
      echo "Options:"
      echo "  1) Chain hooks - run existing hook first, then AI review"
      echo "  2) Replace - backup existing and use AI review only"
      echo "  3) Cancel"
      echo ""
      read -p "Choose option [1/2/3]: " choice
      case "$choice" in
        1)
          # Save original hook for chaining
          mv "$target_hook" "$original_hook"
          chmod +x "$original_hook"
          log_info "Saved original hook for chaining"
          ;;
        2)
          # Backup and replace
          cp "$target_hook" "$target_hook.backup"
          log_info "Backed up existing hook to $target_hook.backup"
          ;;
        *)
          echo "Aborted"
          exit 0
          ;;
      esac
    fi
  fi

  # Create the hook as a wrapper
  if [[ -f "$original_hook" ]]; then
    # Chain mode - run original hook first, then AI review
    cat > "$target_hook" << EOF
#!/usr/bin/env bash
$HOOK_MARKER
# This hook was installed by ai-review (chain mode)
# It runs the original hook first, then AI review
# To uninstall, run: ai-review uninstall

# Run original pre-commit hook first
if [[ -x "$original_hook" ]]; then
  "$original_hook" "\$@"
  ORIGINAL_EXIT=\$?
  if [[ \$ORIGINAL_EXIT -ne 0 ]]; then
    echo ""
    echo "Original pre-commit hook failed (exit code: \$ORIGINAL_EXIT)"
    exit \$ORIGINAL_EXIT
  fi
fi

# Then run AI review
exec "$HOOK_SCRIPT" "\$@"
EOF
    log_info "Installed in chain mode (original hook runs first)"
  else
    # Standalone mode
    cat > "$target_hook" << EOF
#!/usr/bin/env bash
$HOOK_MARKER
# This hook was installed by ai-review
# To uninstall, run: ai-review uninstall

exec "$HOOK_SCRIPT" "\$@"
EOF
  fi
}

cmd_uninstall() {
  check_git_repo

  local hooks_dir=$(get_git_hooks_dir)
  local target_hook="$hooks_dir/pre-commit"
  local hook_type=$(get_hook_type "$hooks_dir")
  local original_hook="$hooks_dir/pre-commit.original"

  log_info "Uninstalling AI Review hook..."

  if [[ ! -f "$target_hook" ]]; then
    log_warn "No pre-commit hook found"
    exit 0
  fi

  # Check if it's our hook
  if ! grep -q "$HOOK_MARKER" "$target_hook" 2>/dev/null; then
    log_error "The existing pre-commit hook is not an AI Review hook"
    echo "Please remove it manually if needed: $target_hook"
    exit 1
  fi

  if [[ "$hook_type" == "husky" ]]; then
    # For husky, just remove our lines from the hook
    local temp_file=$(mktemp)
    grep -v "$HOOK_MARKER" "$target_hook" | grep -v "$HOOK_SCRIPT" > "$temp_file"
    # Remove empty lines at end
    sed -i '' -e :a -e '/^\s*$/d;N;ba' "$temp_file" 2>/dev/null || sed -i -e :a -e '/^\s*$/d;N;ba' "$temp_file" 2>/dev/null || true
    mv "$temp_file" "$target_hook"
    chmod +x "$target_hook"
    log_success "AI Review removed from husky hook"
  else
    # For git hooks, remove the file
    rm "$target_hook"
    log_success "AI Review hook removed"

    # Restore original hook if exists (from chain mode)
    if [[ -f "$original_hook" ]]; then
      mv "$original_hook" "$target_hook"
      log_success "Original pre-commit hook restored"
    # Or restore backup if exists (from replace mode)
    elif [[ -f "$target_hook.backup" ]]; then
      read -p "Restore previous hook from backup? [y/N]: " confirm
      if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
        mv "$target_hook.backup" "$target_hook"
        log_success "Previous hook restored from backup"
      fi
    fi
  fi
}

cmd_config() {
  local action="${1:-show}"

  case "$action" in
    show)
      if [[ ! -f "$CONFIG_FILE" ]]; then
        log_error "No configuration found"
        echo "Run 'ai-review setup' to configure"
        exit 1
      fi

      echo -e "${BOLD}AI Review Configuration${NC}"
      echo "Location: $CONFIG_FILE"
      echo ""

      # Load and display config (mask API key)
      while IFS='=' read -r key value; do
        # Skip comments and empty lines
        [[ "$key" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$key" ]] && continue

        # Remove quotes from value
        value=$(echo "$value" | sed 's/^"//;s/"$//')

        # Mask sensitive values
        if [[ "$key" == *API_KEY* || "$key" == *TOKEN* || "$key" == *SECRET* || "$key" == *PASSWORD* ]]; then
          if [[ ${#value} -gt 8 ]]; then
            masked="${value:0:4}****${value: -4}"
          else
            masked="****"
          fi
          echo "  $key: $masked"
        else
          echo "  $key: $value"
        fi
      done < "$CONFIG_FILE"
      ;;

    set)
      local key="$2"
      local value="$3"

      if [[ -z "$key" || -z "$value" ]]; then
        log_error "Usage: ai-review config set KEY VALUE"
        exit 1
      fi

      # Validate key format (only allow alphanumeric and underscores)
      if [[ ! "$key" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then
        log_error "Invalid config key: $key (only letters, numbers, underscores allowed)"
        exit 1
      fi

      check_config_exists

      # Update or add the key
      if grep -q "^$key=" "$CONFIG_FILE"; then
        sed -i.bak "s|^$key=.*|$key=\"$value\"|" "$CONFIG_FILE"
        rm -f "$CONFIG_FILE.bak"
      else
        echo "$key=\"$value\"" >> "$CONFIG_FILE"
      fi

      log_success "Updated $key"
      ;;

    unset)
      local key="$2"

      if [[ -z "$key" ]]; then
        log_error "Usage: ai-review config unset KEY"
        exit 1
      fi

      # Validate key format (only allow alphanumeric and underscores)
      if [[ ! "$key" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then
        log_error "Invalid config key: $key (only letters, numbers, underscores allowed)"
        exit 1
      fi

      check_config_exists

      # Remove the key
      if grep -q "^${key}=" "$CONFIG_FILE"; then
        sed -i.bak "/^${key}=/d" "$CONFIG_FILE"
        rm -f "$CONFIG_FILE.bak"
        log_success "Removed $key from config"
      else
        log_warn "$key not found in config"
      fi
      ;;

    edit)
      if [[ ! -f "$CONFIG_FILE" ]]; then
        log_error "No configuration found"
        exit 1
      fi

      # Open in default editor
      ${EDITOR:-vi} "$CONFIG_FILE"
      ;;

    *)
      log_error "Unknown config action: $action"
      echo "Usage: ai-review config [show|set|unset|edit]"
      exit 1
      ;;
  esac
}

cmd_status() {
  echo -e "${BOLD}AI Review Status${NC}"
  echo ""

  # Version
  echo "Version: $VERSION"
  echo ""

  # Config status
  echo "Configuration:"
  if [[ -f "$CONFIG_FILE" ]]; then
    log_success "Config exists at $CONFIG_FILE"

    # Check required values
    source "$CONFIG_FILE" 2>/dev/null || true
    if [[ -n "$AI_GATEWAY_URL" ]]; then
      echo "  Gateway URL: $AI_GATEWAY_URL"
    else
      log_warn "AI_GATEWAY_URL not set"
    fi

    if [[ -n "$AI_GATEWAY_API_KEY" ]]; then
      echo "  API Key: ****"
    else
      log_warn "AI_GATEWAY_API_KEY not set"
    fi
  else
    log_error "Config not found at $CONFIG_FILE"
    echo "  Run 'ai-review setup' to configure"
  fi
  echo ""

  # Hook script status
  echo "Hook Script:"
  if [[ -f "$HOOK_SCRIPT" ]]; then
    log_success "Hook script installed at $HOOK_SCRIPT"
  else
    log_error "Hook script not found at $HOOK_SCRIPT"
  fi
  echo ""

  # Current repo status
  echo "Current Repository:"
  if git rev-parse --is-inside-work-tree &> /dev/null; then
    local hooks_dir=$(get_git_hooks_dir)
    local target_hook="$hooks_dir/pre-commit"

    echo "  Repo: $(basename $(git rev-parse --show-toplevel))"

    if [[ -f "$target_hook" ]]; then
      if grep -q "$HOOK_MARKER" "$target_hook" 2>/dev/null; then
        log_success "AI Review hook is installed"
      else
        log_warn "Pre-commit hook exists but is not AI Review"
      fi
    else
      log_info "No pre-commit hook installed"
      echo "  Run 'ai-review install' to enable"
    fi
  else
    log_info "Not in a git repository"
  fi
}

cmd_diff() {
  check_git_repo

  local show_cached=true
  local show_path=true

  # Parse options
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --all|-a)
        show_cached=false
        ;;
      --no-path)
        show_path=false
        ;;
      *)
        ;;
    esac
    shift
  done

  local SHOWLINENUM="$HOOKS_DIR/showlinenum.awk"

  # Check if showlinenum.awk exists
  if [[ ! -f "$SHOWLINENUM" ]]; then
    log_warn "showlinenum.awk not found, downloading..."
    local REPO_URL="https://raw.githubusercontent.com/hiiamtrong/smart-code-review/main"
    curl -sSL "$REPO_URL/scripts/showlinenum.awk" -o "$SHOWLINENUM"
    chmod +x "$SHOWLINENUM"
  fi

  # Get diff with line numbers
  local diff_opts=""
  if [[ "$show_cached" == true ]]; then
    diff_opts="--cached"
  fi

  local awk_opts="show_header=0"
  if [[ "$show_path" == true ]]; then
    awk_opts="$awk_opts show_path=1"
  fi

  # Requires gawk (GNU awk) for gensub() function
  if ! command -v gawk &>/dev/null; then
    log_error "gawk (GNU awk) is required but not found"
    echo ""
    echo "Install gawk:"
    echo "  macOS:  brew install gawk"
    echo "  Ubuntu: sudo apt-get install gawk"
    exit 1
  fi

  git diff --color=always $diff_opts | gawk -f "$SHOWLINENUM" $awk_opts
}

cmd_update() {
  log_info "Updating AI Review..."

  # Download latest versions
  local REPO_URL="https://raw.githubusercontent.com/hiiamtrong/smart-code-review/main"
  local BIN_DIR="$HOME/.local/bin"

  # Update CLI
  echo "Downloading latest CLI..."
  if curl -sSL "$REPO_URL/scripts/local/ai-review" -o "$BIN_DIR/ai-review.new"; then
    mv "$BIN_DIR/ai-review.new" "$BIN_DIR/ai-review"
    chmod +x "$BIN_DIR/ai-review"
    log_success "CLI updated"
  else
    log_error "Failed to download CLI"
    rm -f "$BIN_DIR/ai-review.new"
    exit 1
  fi

  # Update hook script
  echo "Downloading latest hook script..."
  if curl -sSL "$REPO_URL/scripts/local/pre-commit.sh" -o "$HOOK_SCRIPT.new"; then
    mv "$HOOK_SCRIPT.new" "$HOOK_SCRIPT"
    chmod +x "$HOOK_SCRIPT"
    log_success "Hook script updated"
  else
    log_error "Failed to download hook script"
    rm -f "$HOOK_SCRIPT.new"
    exit 1
  fi

  # Update showlinenum.awk
  echo "Downloading showlinenum.awk..."
  if curl -sSL "$REPO_URL/scripts/showlinenum.awk" -o "$HOOKS_DIR/showlinenum.awk.new"; then
    mv "$HOOKS_DIR/showlinenum.awk.new" "$HOOKS_DIR/showlinenum.awk"
    chmod +x "$HOOKS_DIR/showlinenum.awk"
    log_success "showlinenum.awk updated"
  else
    log_warn "Failed to download showlinenum.awk (optional)"
    rm -f "$HOOKS_DIR/showlinenum.awk.new"
  fi

  # Update sonarqube-review.sh
  echo "Downloading sonarqube-review.sh..."
  if curl -sSL "$REPO_URL/scripts/sonarqube-review.sh" -o "$HOOKS_DIR/sonarqube-review.sh.new"; then
    mv "$HOOKS_DIR/sonarqube-review.sh.new" "$HOOKS_DIR/sonarqube-review.sh"
    chmod +x "$HOOKS_DIR/sonarqube-review.sh"
    log_success "sonarqube-review.sh updated"
  else
    log_warn "Failed to download sonarqube-review.sh (optional)"
    rm -f "$HOOKS_DIR/sonarqube-review.sh.new"
  fi

  # Update enable-local-sonarqube.sh
  echo "Downloading enable-local-sonarqube.sh..."
  if curl -sSL "$REPO_URL/scripts/local/enable-local-sonarqube.sh" -o "$HOOKS_DIR/enable-local-sonarqube.sh.new"; then
    mv "$HOOKS_DIR/enable-local-sonarqube.sh.new" "$HOOKS_DIR/enable-local-sonarqube.sh"
    chmod +x "$HOOKS_DIR/enable-local-sonarqube.sh"
    log_success "enable-local-sonarqube.sh updated"
  else
    log_warn "Failed to download enable-local-sonarqube.sh (optional)"
    rm -f "$HOOKS_DIR/enable-local-sonarqube.sh.new"
  fi

  echo ""
  log_success "Update complete!"
  echo "New version: $(ai-review --version 2>/dev/null || echo 'unknown')"
}

cmd_help() {
  cat << EOF
${BOLD}AI Review CLI${NC} - AI-powered code review for git commits

${YELLOW}USAGE:${NC}
    ai-review <command> [options]

${YELLOW}COMMANDS:${NC}
    setup         Configure AI Gateway credentials (interactive)
    install       Install AI Review hook in the current repository
    uninstall     Remove AI Review hook from the current repository
    config        View or modify configuration
                  - ai-review config             Show current config
                  - ai-review config set K V     Set a config value
                  - ai-review config unset K     Remove a config value
                  - ai-review config edit        Open config in editor
    diff          Show staged diff with line numbers
                  - ai-review diff               Show staged changes
                  - ai-review diff --all         Show all changes (not just staged)
                  - ai-review diff --no-path     Hide file paths
    status        Show installation and configuration status
    update        Update AI Review to the latest version
    help          Show this help message

${YELLOW}OPTIONS:${NC}
    --version     Show version number

${YELLOW}CONFIG KEYS:${NC}
    AI_GATEWAY_URL              AI Gateway service endpoint
    AI_GATEWAY_API_KEY          AI Gateway authentication key
    AI_MODEL                    AI model (default: gemini-2.0-flash)
    AI_PROVIDER                 AI provider (default: google)
    ENABLE_SONARQUBE_LOCAL      Enable SonarQube local analysis (true/false)
    SONAR_HOST_URL              SonarQube server URL
    SONAR_TOKEN                 SonarQube authentication token
    SONAR_BLOCK_ON_HOTSPOTS     Block commits on security hotspots (true/false)

    Per-project (via git config):
    aireview.sonarProjectKey    SonarQube project key
    aireview.baseBranch         Branch to compare against (e.g., main)

${YELLOW}EXAMPLES:${NC}
    ai-review setup                                          # Interactive setup
    ai-review install                                        # Enable for current repo
    ai-review config set AI_MODEL gpt-4                      # Change AI model
    ai-review config set ENABLE_SONARQUBE_LOCAL true          # Enable SonarQube
    git config --local aireview.sonarProjectKey "my-project"  # Set project key
    ai-review status                                         # Check setup

${YELLOW}BYPASSING:${NC}
    git commit --no-verify -m "message"

${YELLOW}MORE INFO:${NC}
    Config: $CONFIG_FILE
    Hook:   $HOOK_SCRIPT

EOF
}

# ============================================
# Main
# ============================================

main() {
  local command="${1:-help}"
  shift || true

  case "$command" in
    setup)
      cmd_setup "$@"
      ;;
    install)
      cmd_install "$@"
      ;;
    uninstall)
      cmd_uninstall "$@"
      ;;
    config)
      cmd_config "$@"
      ;;
    status)
      cmd_status "$@"
      ;;
    update)
      cmd_update "$@"
      ;;
    diff)
      cmd_diff "$@"
      ;;
    help|--help|-h)
      cmd_help
      ;;
    --version|-v)
      echo "ai-review version $VERSION"
      ;;
    *)
      log_error "Unknown command: $command"
      echo "Run 'ai-review help' for usage"
      exit 1
      ;;
  esac
}

main "$@"
